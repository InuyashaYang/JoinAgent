# JoinAgent üöÄ

<p align="center">
  <img src="./JoiningAI.png" alt="JoinAgent Logo" width="200"/>
</p>

<p align="center">
  <em>Elevating LLM interactions to unprecedented heights</em>
</p>

<p align="center">
  <a href="README_en.md">English</a> ‚Ä¢
  <a href="README.md">‰∏≠Êñá</a> ‚Ä¢
  <a href="README_fr.md">Fran√ßais</a>
</p>

<p align="center">
  <a href="#key-features">Key Features</a> ‚Ä¢
  <a href="#installation">Installation</a> ‚Ä¢
  <a href="#quick-start">Quick Start</a> ‚Ä¢
  <a href="#documentation">Documentation</a> ‚Ä¢
  <a href="#contributing">Contributing</a> ‚Ä¢
  <a href="#license">License</a>
</p>

---

JoinAgent is a state-of-the-art framework designed for high-performance, concurrent LLM (Large Language Model) interactions. It offers a robust solution for large-scale AI tasks, featuring advanced parsing, validation, and error correction capabilities.

## Key Features

- üöÑ **High Concurrency**: Efficiently manage multiple LLM calls simultaneously
- üß† **Intelligent Parsing**: Seamlessly interpret and structure LLM outputs
- üõ°Ô∏è **Validation & Error Correction**: Ensure data integrity with built-in checks and corrections
- üîÑ **Checkpoint System**: Never lose progress with our advanced checkpointing mechanism
- üîÄ **Flexible Prompting**: Support for both single and multiple prompt templates
- ‚è±Ô∏è **Time Management**: Built-in timeouts to handle unresponsive tasks

## Installation

```bash
pip install joinagent
```

## Quick Start

```python
from JoinAgent import MultiProcessor, MultiLLM, LLMParser, TextDivider

# Set up environment and file path
file_path = 'your_file_path'

# Initialize components
llm = MultiLLM()
parser = LLMParser()
divider = TextDivider(threshold=4096, overlap=128)

# Define templates and prompts
data_template = '''
{"pos1":['mathematical object 1','mathematical object 2',...]}
'''

prompt_template = '''
You are a meticulous assistant. I will give you a text from mathematical materials, please help me extract all the entity mathematical objects from the text and put them into a unified list.
During your work, you will completely turn off the search function and connections to external sources, relying solely on the content of the text itself to complete this task. Do not add new mathematical objects arbitrarily.
If you extract a mathematical object but cannot find its definition in the text, please do not output this mathematical object.
Please do not add anything else at the beginning or end of your output except for this list.
The extraction format is:
{data_template}

Special note: When you encounter examples, exercises, practice problems, etc. in the text, please skip them directly and do not parse their content!!
Numbers, mathematical formulas, algebraic expressions, letters, and other content without Chinese characters are not considered mathematical objects, please remove them!
Please do not output referential mathematical objects like "function f", "matrix B" that are not universally defined but only defined in the context.

Here is the text I'm giving you: {pos1}, please help me extract the mathematical objects and put them into a list.
'''

correction_prompt = '''
You are a rigorous proofreader. I will give you a data structure generated by a large model, please proofread and correct it according to the specified format and content.

The proofreading format is:
{data_template}

Here is the text to be verified: {answer}, please help me proofread and correct this list.
'''

def validation(text):
    return True

# Create MultiProcessor instance
processor = MultiProcessor(llm=llm, 
                           parse_method=parser.parse_dict, 
                           data_template=data_template, 
                           prompt_template=prompt_template, 
                           correction_template=correction_prompt, 
                           validator=validation)

# Process text
text_list = divider.divide(file_path)
text_dict = {index: {"pos1": value} for index, value in enumerate(text_list)}

# Execute multi-task processing
results = processor.multitask_perform(text_dict, num_threads=5)

# Print results
for index, result in results.items():
    print(f"Chunk {index}: {result}")

```


## License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.

---

<p align="center">
  Crafted with ‚ù§Ô∏è by <a href="https://github.com/InuyashaYang">JoiningAI</a>
</p>